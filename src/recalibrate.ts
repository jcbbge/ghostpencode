import { readFileSync, writeFileSync, existsSync } from 'fs';
import { homedir } from 'os';
import { join } from 'path';
import { adjustForContrastPreservingHue, getContrastRatio } from './utils';
import { Palette } from './types';
import { syncFromGhostty, syncFromOpenCode } from './sync';

const GHOSTTY_THEMES_DIR = join(homedir(), '.config/ghostty/themes');
const OPENCODE_THEMES_DIR = join(homedir(), '.config/opencode/themes');

/**
 * Detect if theme name is kebab-case (OpenCode) or Title Case (Ghostty)
 */
function detectThemeFormat(name: string): 'opencode' | 'ghostty' {
  // If it contains dashes or is all lowercase, it's OpenCode
  if (name.includes('-') || name === name.toLowerCase()) {
    return 'opencode';
  }
  // Otherwise it's Title Case (Ghostty)
  return 'ghostty';
}

/**
 * Read Ghostty theme file and extract palette
 */
function readGhosttyTheme(name: string): Palette | null {
  const themePath = join(GHOSTTY_THEMES_DIR, name);
  if (!existsSync(themePath)) {
    return null;
  }

  const content = readFileSync(themePath, 'utf-8');
  const lines = content.split('\n');

  const palette: any = {};
  const paletteMap: Record<number, keyof Palette> = {
    0: 'black',
    1: 'red',
    2: 'green',
    3: 'yellow',
    4: 'blue',
    5: 'magenta',
    6: 'cyan',
    7: 'white',
    8: 'brightBlack',
    9: 'brightRed',
    10: 'brightGreen',
    11: 'brightYellow',
    12: 'brightBlue',
    13: 'brightMagenta',
    14: 'brightCyan',
    15: 'brightWhite',
  };

  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith('palette = ')) {
      const match = trimmed.match(/palette = (\d+)=(#[0-9a-f]{6})/i);
      if (match) {
        const index = parseInt(match[1]);
        const color = match[2];
        const key = paletteMap[index];
        if (key) palette[key] = color;
      }
    } else if (trimmed.startsWith('background = ')) {
      palette.background = trimmed.split('=')[1].trim();
    } else if (trimmed.startsWith('foreground = ')) {
      palette.foreground = trimmed.split('=')[1].trim();
    } else if (trimmed.startsWith('cursor-color = ')) {
      palette.cursor = trimmed.split('=')[1].trim();
    } else if (trimmed.startsWith('selection-background = ')) {
      palette.selection = trimmed.split('=')[1].trim();
    }
  }

  return palette as Palette;
}

/**
 * Read OpenCode theme file and extract palette from defs
 */
function readOpenCodeTheme(name: string): Palette | null {
  const themePath = join(OPENCODE_THEMES_DIR, `${name}.json`);
  if (!existsSync(themePath)) {
    return null;
  }

  const content = readFileSync(themePath, 'utf-8');
  const theme = JSON.parse(content);

  if (!theme.defs) return null;

  const defs = theme.defs;
  return {
    background: defs.bg,
    foreground: defs.fg,
    cursor: defs.cursor,
    selection: defs.selection,
    black: defs.black,
    red: defs.red,
    green: defs.green,
    yellow: defs.orange,
    blue: defs.blue,
    magenta: defs.magenta,
    cyan: defs.cyan,
    white: defs.white,
    brightBlack: defs.brightBlack,
    brightRed: defs.brightRed,
    brightGreen: defs.brightGreen,
    brightYellow: defs.brightOrange,
    brightBlue: defs.brightBlue,
    brightMagenta: defs.brightMagenta,
    brightCyan: defs.brightCyan,
    brightWhite: defs.brightWhite,
  };
}

/**
 * Write Ghostty theme file
 */
function writeGhosttyTheme(name: string, palette: Palette): void {
  const themePath = join(GHOSTTY_THEMES_DIR, name);

  const content = `# ${name}
# Generated by ghostpencode

palette = 0=${palette.black}
palette = 1=${palette.red}
palette = 2=${palette.green}
palette = 3=${palette.yellow}
palette = 4=${palette.blue}
palette = 5=${palette.magenta}
palette = 6=${palette.cyan}
palette = 7=${palette.white}
palette = 8=${palette.brightBlack}
palette = 9=${palette.brightRed}
palette = 10=${palette.brightGreen}
palette = 11=${palette.brightYellow}
palette = 12=${palette.brightBlue}
palette = 13=${palette.brightMagenta}
palette = 14=${palette.brightCyan}
palette = 15=${palette.brightWhite}
background = ${palette.background}
foreground = ${palette.foreground}
cursor-color = ${palette.cursor}
cursor-text = ${palette.background}
selection-background = ${palette.selection}
selection-foreground = ${palette.foreground}
`;

  writeFileSync(themePath, content, 'utf-8');
}

/**
 * Update OpenCode theme defs with new palette
 */
function writeOpenCodeTheme(name: string, palette: Palette): void {
  const themePath = join(OPENCODE_THEMES_DIR, `${name}.json`);
  const content = readFileSync(themePath, 'utf-8');
  const theme = JSON.parse(content);

  theme.defs = {
    ...theme.defs,
    bg: palette.background,
    fg: palette.foreground,
    cursor: palette.cursor,
    selection: palette.selection,
    black: palette.black,
    red: palette.red,
    green: palette.green,
    orange: palette.yellow,
    blue: palette.blue,
    magenta: palette.magenta,
    cyan: palette.cyan,
    white: palette.white,
    brightBlack: palette.brightBlack,
    brightRed: palette.brightRed,
    brightGreen: palette.brightGreen,
    brightOrange: palette.brightYellow,
    brightBlue: palette.brightBlue,
    brightMagenta: palette.brightMagenta,
    brightCyan: palette.brightCyan,
    brightWhite: palette.brightWhite,
  };

  writeFileSync(themePath, JSON.stringify(theme, null, 2), 'utf-8');
}

/**
 * Display palette as colored ANSI blocks
 */
export function displayColoredBlocks(palette: Palette): void {
  const colors = [
    palette.black,
    palette.red,
    palette.green,
    palette.yellow,
    palette.blue,
    palette.magenta,
    palette.cyan,
    palette.white,
    palette.brightBlack,
    palette.brightRed,
    palette.brightGreen,
    palette.brightYellow,
    palette.brightBlue,
    palette.brightMagenta,
    palette.brightCyan,
    palette.brightWhite,
  ];

  let output = '';
  for (const hex of colors) {
    const rgb = parseInt(hex.slice(1), 16);
    const r = (rgb >> 16) & 0xff;
    const g = (rgb >> 8) & 0xff;
    const b = rgb & 0xff;
    output += `\x1b[38;2;${r};${g};${b}m█\x1b[0m`;
  }

  console.log(output);
}

/**
 * Apply contrast recalibration to all non-background colors
 */
function recalibratePalette(palette: Palette): Palette {
  const recalibrated = { ...palette };
  const bg = palette.background;

  // Primary text colors - WCAG AA (4.5:1)
  recalibrated.foreground = adjustForContrastPreservingHue(palette.foreground, bg, 4.5);
  recalibrated.white = adjustForContrastPreservingHue(palette.white, bg, 4.5);

  // Dark ANSI colors (3.5:1)
  recalibrated.red = adjustForContrastPreservingHue(palette.red, bg, 3.5);
  recalibrated.green = adjustForContrastPreservingHue(palette.green, bg, 3.5);
  recalibrated.yellow = adjustForContrastPreservingHue(palette.yellow, bg, 3.5);
  recalibrated.blue = adjustForContrastPreservingHue(palette.blue, bg, 3.5);
  recalibrated.magenta = adjustForContrastPreservingHue(palette.magenta, bg, 3.5);
  recalibrated.cyan = adjustForContrastPreservingHue(palette.cyan, bg, 3.5);

  // Bright ANSI colors (4.0:1)
  recalibrated.brightRed = adjustForContrastPreservingHue(palette.brightRed, bg, 4.0);
  recalibrated.brightGreen = adjustForContrastPreservingHue(palette.brightGreen, bg, 4.0);
  recalibrated.brightYellow = adjustForContrastPreservingHue(palette.brightYellow, bg, 4.0);
  recalibrated.brightBlue = adjustForContrastPreservingHue(palette.brightBlue, bg, 4.0);
  recalibrated.brightMagenta = adjustForContrastPreservingHue(palette.brightMagenta, bg, 4.0);
  recalibrated.brightCyan = adjustForContrastPreservingHue(palette.brightCyan, bg, 4.0);
  recalibrated.brightWhite = adjustForContrastPreservingHue(palette.brightWhite, bg, 4.0);

  return recalibrated;
}

// Queue for pre-loaded answers (when stdin is piped)
let answerQueue: string[] = [];
let answersLoaded = false;

/**
 * Load all answers from stdin if piped
 */
async function loadAnswersIfPiped(): Promise<void> {
  if (answersLoaded) return;
  answersLoaded = true;

  if (!process.stdin.isTTY) {
    // Stdin is piped, read all input
    const chunks: Buffer[] = [];
    for await (const chunk of process.stdin) {
      chunks.push(chunk);
    }
    const input = Buffer.concat(chunks).toString('utf8');
    answerQueue = input.split('\n').map(line => line.trim()).filter(Boolean);
  }
}

/**
 * Prompt user for input
 */
export async function prompt(message: string): Promise<boolean> {
  await loadAnswersIfPiped();

  if (answerQueue.length > 0) {
    // Use pre-loaded answer
    const input = answerQueue.shift()!.toLowerCase();
    console.log(input); // Echo the answer
    return input === 'y' || input === 'yes';
  }

  // Interactive mode - use Bun's built-in prompt if available
  if (typeof Bun !== 'undefined' && Bun.prompt) {
    const answer = await Bun.prompt(message, 'n');
    return answer?.toLowerCase() === 'y';
  }

  // Fallback to reading from stdin
  return new Promise((resolve) => {
    process.stdout.write(message);
    process.stdin.once('data', (data) => {
      const input = data.toString().trim().toLowerCase();
      if (input === 'y' || input === 'yes') {
        resolve(true);
      } else {
        resolve(false);
      }
    });
  });
}

/**
 * Main recalibration flow
 */
export async function recalibrateTheme(themeName: string): Promise<void> {
  const format = detectThemeFormat(themeName);

  console.log(`\nDetected format: ${format === 'opencode' ? 'OpenCode (kebab-case)' : 'Ghostty (Title Case)'}`);

  // Read theme
  let palette: Palette | null = null;
  if (format === 'opencode') {
    palette = readOpenCodeTheme(themeName);
  } else {
    palette = readGhosttyTheme(themeName);
  }

  if (!palette) {
    console.error(`\nERROR: Theme "${themeName}" not found`);
    process.exit(1);
  }

  console.log(`Theme: ${themeName}\n`);

  // Display current colors
  displayColoredBlocks(palette);

  // Prompt for recalibration
  const shouldRecalibrate = await prompt('\nINITIATE CONTRAST RECALIBRATION? [y/n]: ');

  if (!shouldRecalibrate) {
    console.log('Operation cancelled.');
    return;
  }

  // Apply recalibration
  const recalibrated = recalibratePalette(palette);

  // Write back to source
  if (format === 'opencode') {
    writeOpenCodeTheme(themeName, recalibrated);
    console.log(`\n✓ OpenCode theme recalibrated: ${themeName}`);
  } else {
    writeGhosttyTheme(themeName, recalibrated);
    console.log(`\n✓ Ghostty theme recalibrated: ${themeName}`);
  }

  // Prompt for sync
  const shouldSync = await prompt('\nSYNC TO ALTERNATE FORMAT? [y/n]: ');

  if (shouldSync) {
    if (format === 'opencode') {
      syncFromOpenCode(themeName);
    } else {
      syncFromGhostty(themeName);
    }
  }

  console.log('\nRecalibration complete.');
}
